-- this script should be placed on a standard cube object with a color tint with alpha = 0


local testPlayers = false
local testPlayerCount = 6

local ignoreReach = false
local plusOnePool = false

local allChits = {}

local playmats = {}

local factions = {
   { name = "Marquise de Cat", color = "Orange", reachVal = 10, setupName = "Marquise"},
   { name = "Underground Duchy", color = "Brown", reachVal = 8, setupName = "Duchy"},
   { name = "Eyrie Dynasties", color = "Blue", reachVal = 7, setupName = "Eyrie"},
   { name = "Vagabond", color = "White", reachVal = 5, setupName = "Vagabond"},
   { name = "Riverfolk Company", color = "Teal", reachVal = 5, setupName = "Riverfolk"},
   { name = "Woodland Alliance", color = "Green", reachVal = 3, setupName = "Woodland"},
   { name = "Corvid Conspiracy", color = "Purple", reachVal = 3, setupName = "Corvid"},
   { name = "Vagabond (Second)", color = "Red", reachVal = 2, setupName = "Vagabond"},
   { name = "Lizard Cult", color = "Yellow", reachVal = 2, setupName = "Lizard"},
}

local reachMins = {
   [1] = 0, -- for testing
   [2] = 17,
   [3] = 18,
   [4] = 21,
   [5] = 25,
   [6] = 28,
}

local selections = {}
local selectionOrder = {}
local turnOrder = {}
local currentReach = 0

local xmlDefaults = {
   tag = "Defaults",
   children = {
      {
         tag = "Button",
         attributes = {
            textColor = "#dcdccc",
            color = "#1c1c1c",
            fontSize = "90",
         }
      },
      {
         tag = "ToggleButton",
         attributes = {
            selectedTextColor = "#dcdccc",
            deselectedTextColor = "#dcdccc",
            deselectedColor = "#1c1c1c",
            selectedColor = "#1c1c1c",
            color = "#1c1c1c",
            colors = "#1c1c1c|#1c1c1c|#3f3f3f|#1c1c1c",
            textColors = "#dcdccc|#dcdccc|#dcdccc|#dcdccc",
            fontSize = "50",
         }
      },
      {
         tag = "Text",
         attributes = {
            color = "#dcdccc",
            fontSize = "90",
         }
      },
      {
         tag = "InputField",
         attributes = {
            textColor = "#dcdccc",
            colors = "#1c1c1c|#1c1c1c|#1c1c1c|#1c1c1c",
            fontSize = "90",
         }
      },
   }
}

local xmlPanelStart = {
   tag = "Panel",
   attributes = {
      id = "start",
      width = "900",
      height = "450",
      showAnimation = "Grow",
      hideAnimation = "Shrink",
      padding = "7",
   },
   children = {
      {
         tag = "VerticalLayout",
         attributes = {
            spacing = "7"
         },
         children = {
            { tag = "Button", attributes = {
                 text = "Normal Draft",
                 onClick="chooseOptions",
                 tooltip="<size=50>Turn and draft order are selected and then players\nchoose from all available factions. Minimum reach is\nrequired by default, but can be disabled.</size>"
            }},
            { tag = "Button", attributes = {
                 text = "Plus One Pool Draft",
                 onClick="chooseOptions(plusonepool)",
                 tooltip="<size=50>Turn and draft order are selected and then players\nchoose from a randomly generated pool of factions.\nA minimum reach of 17 is required.</size>"
            }},
            { tag = "Button", attributes = {
                 text = "No Draft",
                 onClick="destruct()",
                 tooltip="<size=50>This will remove the drafting tool from your table.</size>"
            }}
         }
      }
   }
}

local xmlLabelDraftOrder = {
   tag = "Text",
   attributes = {
      color = "#dcdccc",
      position = "-200 500 -5",
      fontSize = "40",
      text = "Draft\nOrder\n↓"
   },
}

local xmlLabelTurnOrder = {
   tag = "Text",
   attributes = {
      color = "#dcdccc",
      position = "200 500 -5",
      fontSize = "40",
      text = "↑\nTurn\nOrder"
   },
}

function onLoad()
   self.setColorTint(Color(0, 0, 0, 0))
   self.setLock(true)

   self.UI.setXmlTable({xmlDefaults, xmlPanelStart})

   playmats = find_objects_by_name("Faction Selection")
end

function getPlayers()
   local allPlayers = Player.getPlayers()
   local players = {}
   for _, p in pairs(allPlayers) do
      if p.color ~= "Black" then
         table.insert(players, p)
      end
   end
   if not testPlayers then
      return players
   end

   local colors = Player.getAvailableColors()
   while #players < testPlayerCount do
      table.insert(players, {
                      steam_name = "player" .. #players,
                      steam_id = #players,
                      color = colors[#players]
      })
   end

   return players
   
end

function chooseOptions(player, arg, el)
   self.UI.hide("start")
   if arg == "plusonepool" then
      plusOnePool = true
   end
   
   local options = {
      tag = "Panel",
      attributes = {
         id = "options",
         active = "false",
         color = "#1c1c1c",
         width = "900",
         height = "800",
         showAnimation = "Grow",
         hideAnimation = "Shrink",
         padding = "7",
      },
      children = {
         {
            tag = "VerticalLayout",
            attributes = {
               spacing = "7"
            },
            children = {
               { tag = "Text",
                 attributes = {
                    text = (plusOnePool and "Plus One Pool" or "Draft"),
               }},
               {
                  tag = "HorizontalLayout",
                  attributes = {
                     padding = "10",
                     active = (not plusOnePool),
                  },
                  children = {
                     { tag = "Text", attributes = { text = "Ignore Reach?" }},
                     { tag = "ToggleButton",
                       attributes = {
                          id = "toggle-reach",
                          text = "No",
                          onValueChanged = "setIgnoreReach",
                     }},
               }},
               {
                  tag = "HorizontalLayout",
                  attributes = {
                     padding = "10" 
                  },
                  children = {
                     { tag = "Text", attributes = { text = "Mock Draft?" }},
                     { tag = "ToggleButton",
                       attributes = {
                          id = "toggle-mock",
                          text = "No",
                          onValueChanged = "setMockDraft",
                     }},
               }},
               { tag = "HorizontalLayout",
                 attributes = {
                    id = "layout-mock",
                    spacing = "7",
                    active = "false",
                 },
                 children = {
                    { tag = "Text",
                      attributes = {
                         fontSize = "70",
                         text = "Mock Player Count: ",
                    }},
                    { tag = "InputField",
                      attributes = {
                         id = "input-mock",
                         text = "",
                         fontSize = "70",
                         onValueChanged = "setMockPlayerCount",
                         characterValidation="Integer"
                    }},
                 }
               },
               { tag = "Button",
                 attributes = {
                    text = "Start",
                    onClick="start",
               }},
            }
         }
      }
   }

   local showOptionsUI = function()
      self.UI.show("options")
   end
   
   local setOptionsUI = function()
      self.UI.setXmlTable({
            xmlDefaults,
            options,
      })
      -- wait to show the UI until it exists (show enables the animation)
      Wait.frames(showOptionsUI, 3)
   end

   -- wait for the previous UI to fully hide (otherwise tooltips get "stuck")
   Wait.frames(setOptionsUI, 10)
end

function setIgnoreReach(player, value, el)
   ignoreReach = not ignoreReach
   self.UI.setAttribute("toggle-reach", "isOn", ignoreReach)
   self.UI.setAttribute("toggle-reach", "text", (ignoreReach and "Yes" or "No"))
   self.UI.setAttribute("toggle-reach", "color", "#1c1c1c")
   self.UI.setAttribute("toggle-reach", "textColor", "#dcdccc")
end

function setMockDraft(player, value, el)
   testPlayers = not testPlayers
   self.UI.setAttribute("toggle-mock", "isOn", testPlayers)
   self.UI.setAttribute("toggle-mock", "text", (testPlayers and "Yes" or "No"))
   self.UI.setAttribute("toggle-mock", "color", "#1c1c1c")
   self.UI.setAttribute("toggle-mock", "textColor", "#dcdccc")
   if testPlayers then
      self.UI.show("layout-mock")
      self.UI.setAttribute("input-mock", "text", tostring(testPlayerCount))
      self.UI.setAttribute("options", "height", 950)
   else
      self.UI.hide("layout-mock")
      self.UI.setAttribute("options", "height", 800)
   end
end

function setMockPlayerCount(player, value, el)
   testPlayerCount = tonumber(value)
   if testPlayerCount == nil then
      testPlayerCount = 3
   end
   if testPlayerCount > 6 then
      testPlayerCount = 6
   end
   self.UI.setAttribute("input-mock", "text", tostring(testPlayerCount))
end

function start(player, value, element)
   self.UI.hide("options")

   if plusOnePool then
      broadcastToAll("Attempting to generate faction pool")
      factions = generateFactionPool()
   end
   
   log("starting draft")
   local players = getPlayers()
   for _, player in ipairs(players) do
      if player.changeColor then
         player.changeColor("Grey")
      end
   end

   selections = {}

   local chits = {}
   for i, p in ipairs(players) do
      local pname = p.steam_name or p.color
      chits[i] = {
         name = pname,
         description = p.steam_id or ""
      }
   end


   callAttention(Vector(0, 0, 0), 20)
   allChits = spawnChits(chits)

   local selectOrder = function()
      self.UI.setXmlTable({{}})
      rollForOrder(allChits)
   end

   Wait.time(selectOrder, 1)
end

function rollForOrder(chits)
   if #chits < 1 then
      return
   end

   self.UI.setXmlTable({
         xmlLabelTurnOrder,
         xmlLabelDraftOrder,
   })
   
   local bagPos = self.positionToWorld(Vector(0, 0, 0))
   
   local bag = spawnObject({
         type = "Bag",
         position = bagPos,
         callback_function = function(o)
            for i, chit in ipairs(chits) do
               chit.setLock(false)
               chit.setPositionSmooth(bagPos + Vector(0, 2+(i*1.25), 0), false, false)
            end
         end
   })

   local finishedOrderSelection = function()
      log("chits at rest again")
      bag.destruct()
      allChits = chits
      startDraft()
   end
   
   local shuffleAndPick = function()
      log("chits in bag")
      bag.randomize()
      bag.randomize()

      for i = 1, #chits, 1 do

         local takeCallback = function (o)
            chits[i] = o
            if i == #chits then
               waitForRest(chits, finishedOrderSelection)
            end
         end
         
         Wait.time(function() takeChit(bag, i, takeCallback) end, i*0.5)
      end
   end

   local chitsInBag = function()
      for _, chit in ipairs(chits) do
         if getObjectFromGUID(chit.guid) ~= nil then
            return false
         end
      end
      return true
   end
   
   Wait.condition(shuffleAndPick, chitsInBag)
end

function takeChit(bag, i, cb)
   local pos = self.positionToWorld(Vector(0, 1, 1+(i*1.25)))
   chit = bag.takeObject({
         position = pos,
         smooth = true,
         callback_function = function(o)
            cb(o)
         end
   })
   setChitUI(chit)
   return chit
end

function waitForRest(chits, callback, waitSec)
   if waitSec == nil then
      waitSec = 1
   end
   Wait.condition(
      function()
         Wait.time(callback, waitSec)
      end,
      function()
         for _, chit in ipairs(chits) do
            if not chit.resting then
               return false
            end
         end
         return true
      end
   )
end

function startDraft()
   currentReach = 0
   local turns = {}
   local i = #allChits
   for _, d in spairs(allChits, function(t, a, b) return t[a].getPosition().z < t[b].getPosition().z end) do
      selectionOrder[i] = {name = d.getName(), id = d.getDescription()}
      selections[d.getDescription()] = nil
      i = i-1
   end


   local factionButtons = {
      {
         tag = "Text",
         attributes = {
            id = "reach-counter",
            color = "#dcdccc",
            fontSize = 30,
            text = "Reach: 0/" .. getMinReach(#selectionOrder),
         }
      },
      {
         tag = "Text",
         attributes = {
            id = "turn-display",
            color = "#dcdccc",
            fontSize = 30,
            text = selectionOrder[1].name .. "'s Pick"
         }
      }
   }

   for i, f in ipairs(factions) do
      factionButtons[i+2] = {
         tag = "Button",
         attributes = {
            id = "btn-faction-"..i,
            text = f.name .. " (" .. f.reachVal .. ")",
            color = f.color,
            fontSize = 30,
            textColor = "#1c1c1c",
            onClick = "selectFaction(".. i .. ")",
            showAnimation = "Grow",
            hideAnimation = "Shrink",
         }
      }

      if i == 8 then
         factionButtons[i+2].attributes.active = false
      end
   end
   
   local pickerHeight = #factions * 100
   local factionPicker = {
      tag = "Panel",
      attributes = {
         position = "0 " .. (-1*(pickerHeight/2)) .. " -50",
         width = "400",
         color = "#1c1c1c",
         padding = 7,
         height = pickerHeight,
         id = "btns-draft-selection",
         showAnimation = "Grow",
         hideAnimation = "Shrink",
         active = false,
      },
      children = {
         {
            tag = "VerticalLayout",
            attributes = {
               spacing = 7,
            },
            children = factionButtons
         }
      }
   }

   self.UI.setXmlTable({
         factionPicker,
         xmlLabelTurnOrder,
         xmlLabelDraftOrder,
   })
   callAttention(Vector(0, 0, -4), 25)
   Wait.frames(
      function()
         self.UI.show("btns-draft-selection")
         hideUnavailable()
         broadcastToAll("Draft started! If you cannot see the faction buttons, leave and re-join the game.")
      end,
      7
   )
   
end

function callAttention(pos, distance)
   for _, p in ipairs(Player.getPlayers()) do
      p.lookAt({
            position = self.positionToWorld(pos),
            pitch = 75,
            yaw = 0,
            distance = distance or 10,
      })
   end
end

function hideUnavailable(choices)
   if ignoreReach then
      return
   end
   local playerCount = #selectionOrder
   local minReach = getMinReach(playerCount)
   
   local available = {}
   for i, f in ipairs(factions) do
      self.UI.setAttributes(
         "btn-faction-"..i,
         {
            interactable = false,
            color =  "#3f3f3f"
         }
      )
      local taken = false
      for _, s in pairs(selections) do
         if s ~= nil then
            if s.color == f.color then
               taken = true
            end
         end
      end
      if not taken then
         table.insert(available, {
                         id = i,
                         faction = f,
         })
      end
   end

   local selectedCount = 0
   for _, s in pairs(selections) do
      if s ~= nil then
         selectedCount = selectedCount + 1
      end
   end
   
   
   local pickable = {}
   for i, v in pairs(available) do
      if(v ~= nil) then
         local tTemp = sCopy(available)
         tTemp[i] = nil
         if(  validateSetup(tTemp, currentReach+v.faction.reachVal, playerCount - selectedCount-1) ) then
            table.insert(pickable, v)
         end
      end
   end

   
   for i, v in pairs(pickable) do
      if v ~= nil then
         self.UI.setAttributes(
            "btn-faction-"..v.id,
            {
               color = v.faction.color,
               interactable = true,
            }
         )
      end
   end
end

local maxGenerationAttempts = 50

function factionSort(a, b)
   return a.reachVal > b.reachVal
end

function generateFactionPool(attemptsLeft)
   if attemptsLeft == nil then
      attemptsLeft = maxGenerationAttempts
   end
   local playerCount = #(getPlayers())
   local selection = pullRandomFactions(factions, playerCount+1)
   local left = selection.left
   local newFactions = selection.selected

   attemptsLeft = attemptsLeft-1
   while not all17(newFactions, playerCount) do
      if #left == 0 then
         if attemptsLeft < 5 then
            broadcastToAll("Faction pool invalid!")
            broadcastToAll(attemptsLeft .. " attempts left.")
         end
         if attemptsLeft == 0 then
            return factions
         else
            return generateFactionPool(attemptsLeft)
         end
      end
      table.remove(newFactions, #newFactions)
      table.insert(newFactions, left[#left])
      table.remove(left, #left)
   end
   
   table.sort(newFactions, factionSort)
   
   broadcastToAll("Faction pool valid!")
   broadcastToAll(maxGenerationAttempts-attemptsLeft .. " attempts.")

   return newFactions
end

function all17(options, playerCount)

   if #options == playerCount then
      local reach = 0
      for _, f in ipairs(options) do
         reach = reach + f.reachVal
      end
      return reach >= 17
   end

   for i, f in ipairs(options) do
      local opts = sCopy(options)
      table.remove(opts, i)
      if not all17(opts, playerCount) then
         return false
      end
   end
   return true
end

function pullRandomFactions(source, count)
   local newFactions = {}
   local unselected = sCopy(source)
   for i = 1, count, 1 do
      local faction = { name = "Vagabond (Second)"}
      -- don't allow second vagabond
      local randI = 0
      while faction.name == "Vagabond (Second)" do
         randI = math.random(1, #unselected)
         faction = unselected[randI]
      end
      table.insert(newFactions, faction)
      table.remove(unselected, randI)
   end
   table.sort(newFactions, factionSort)
   table.sort(unselected, factionSort)
   return {selected = newFactions, left = unselected}
end

function getMinReach(playerCount)
   if playerCount < 2 then
      return 0
   end
   if plusOnePool then
      return 17
   end
   if ignoreReach then
      return 0
   end
   return reachMins[playerCount]
end

function validateSetup(possible, reach, playersLeft)
   local playerCount = #(getPlayers())
   local minReach = getMinReach(playerCount)

   if reach >= minReach then
      return true
   end

   for i, v in pairs(possible) do
      if(v ~= nil) then
         local tTemp = sCopy(possible)
         if(playersLeft <= 0) then
            return false
         end

         local reachTmp = reach + v.faction.reachVal

         if(reachTmp >= minReach) then
            return true
         end

         tTemp[i] = nil
         if( validateSetup(tTemp, reachTmp, playersLeft-1) ) then
            return true
         else
            possible[i] = nil
         end
      end
   end
end

function selectFaction(player, value, elem)
   
   local nextID = ""
   local nextName = ""
   local currentOrderIndex = -1
   for i, c in ipairs(selectionOrder) do
      if selections[c.id] == nil then
         nextID = c.id
         nextName = c.name
         currentOrderIndex = i
         break
      end
   end


   if player.steam_id ~= nextID and #(tostring(nextID)) > 1 then
      broadcastToColor("Not your turn yet", player.color)
      return
   end

   local faction = factions[tonumber(value)]
   if testPlayers then
      selections[nextID] = faction
   else
      selections[player.steam_id] = faction
   end
   currentReach = currentReach + faction.reachVal

   self.UI.setAttributes(
      "reach-counter",
      {
         text = "Reach: " .. currentReach .. "/" .. getMinReach(#selectionOrder),
         color = "#dcdccc",
      }
   )

   self.UI.hide("btn-faction-"..value)
   local bgColor = self.UI.getAttribute("btn-faction-"..value, "color")
   local fgColor = self.UI.getAttribute("btn-faction-"..value, "textColor")
   local text = self.UI.getAttribute("btn-faction-"..value, "text")
   self.UI.setAttributes(
      "btn-faction-"..value,
      {
         color = fgColor,
         text = text .. "\n" .. nextName .. " (" .. currentOrderIndex .. ")",
         textColor = bgColor,
         interactable = false,
      }
   )
   self.UI.show("btn-faction-"..value)
   
   table.insert(turnOrder, 1, faction.color)

   if faction.setupName == "Vagabond" and not plusOnePool then
      self.UI.show("btn-faction-8")
   end

   local playmat = getNextPlaymat()
   
   local prepForNextSelection = function()
      if selectionOrder[currentOrderIndex+1] ~= nil then
         self.UI.setAttribute("turn-display", "text", selectionOrder[currentOrderIndex+1].name .. "'s Pick")
         hideUnavailable()
      else
         self.UI.setAttribute("turn-display", "text", "Draft Finished! GLHF!")
         Wait.frames(endDraft, 7)
      end
   end

   local handleVagabond = function()
      if faction.name == "Vagabond (Second)" then
         playmat.call("setColorRemote", faction.color)
      end
      if faction.setupName == "Vagabond" then
         playmat.UI.setAttribute("subpanel", "active", false)
      end
   end
   
   local seatPlayer = function()
      player.changeColor(faction.color)
      
      if playmat == nil then
         prepForNextSelection()
         return
      end
      playmat.call(
         "spawnRemote",
         {
            player = Player[faction.color],
            faction = faction.setupName,
      })
      
      Wait.frames(
         function()
            handleVagabond()
            prepForNextSelection()
         end,
         3
      )
   end
   
   Wait.frames(seatPlayer, 30)

   
end

function getNextPlaymat()
   for i, playmat in ipairs(playmats) do
      if playmat ~= "" then
         playmats[i] = ""
         return playmat
      end
   end
   return nil
end

function playerName(playerID)
   for i, p in ipairs(Player.getPlayers()) do
      if tostring(p.steam_id) == tostring(playerID) then
         return p.steam_name or player.color
      end
   end
   return tostring(playerID)
end

function endDraft()
   for _, d in ipairs(allChits) do
      d.destruct()
   end
   Turns.enable = true
   Turns.type = 2
   Turns.order = turnOrder
   Turns.turn_color = turnOrder[1]
   for i, f in ipairs(factions) do
      self.UI.setAttribute("btn-faction-"..i, "interactable", false)
   end
   self.UI.hide("btns-draft-selection")

   local factionButtons = {
      {
         tag = "Text",
         attributes = {
            id = "turn-display",
            color = "#dcdccc",
            fontSize = 30,
            text = "Draft Finished! GLHF!"
         }
      },
      {
         tag = "Text",
         attributes = {
            id = "turn-display",
            color = "#dcdccc",
            fontSize = 30,
            text = "Turn Order:"
         }
      }
   }

   for i, c in ipairs(turnOrder) do
      local id = (Player[c].steam_id) or c
      local faction = nil
      for i, f in ipairs(factions) do
         if c == f.color then
            faction = f
            break
         end
      end

      local text = faction.name .. "\n" .. playerName(id)
      if plusOnePool then
         local cardDraw = "Draw " .. (2+i) .. " cards"
         text = text .. "\n" .. cardDraw
         if Player[faction.color] and Player[faction.color].seated then
            broadcastToColor(cardDraw, faction.color)
         end
      end

      
      table.insert(
         factionButtons,
         {
            tag = "Button",
            attributes = {
               id = "btn-faction-"..i,
               text = text,
               textColor = faction.color,
               interactable = false,
               fontSize = 30,
               color = "#1c1c1c",
            }
         }
      )
   end

   table.insert(
      factionButtons,
      {
         tag = "Button",
         attributes = {
            text = "Remove",
            textColor = "#dcdccc",
            fontSize = 30,
            color = "#1c1c1c",
            onClick = "destruct()"
         }
      }
   )
   
   local pickerHeight = 300 + (#factions * (plusOnePool and 150 or 100))
   local factionPicker = {
      tag = "Panel",
      attributes = {
         position = "0 " .. (-1*(pickerHeight/2)) .. " -50",
         width = "400",
         color = "#1c1c1c",
         id = "btns-draft-selection",
         padding = 7,
         height = pickerHeight,
         showAnimation = "Grow",
         hideAnimation = "Shrink",
         active = false,
      },
      children = {
         {
            tag = "VerticalLayout",
            attributes = {
               spacing = 7,
            },
            children = factionButtons
         }
      }
   }

   Wait.frames(
      function()
         self.UI.setXmlTable({factionPicker})

         Wait.frames(
            function()
               self.UI.show("btns-draft-selection")
            end, 3)
      end
      , 3)
end

function destruct()
   self.destruct()
end

function spawnChits(toSpawn)
   local chits = {}
   for i, chitConf in ipairs(toSpawn) do
      local name = chitConf.name or ""
      local angleStep = 360 / (#chits+1)
      for i, chit in ipairs(chits) do
         local pos = findGlobalPosWithLocalDirection(angleStep*(i-1))
         chit.setPositionSmooth(pos, false, true)
      end
      
      local rollLocation = findGlobalPosWithLocalDirection(360-angleStep)
      
      local spawnedChit = spawnObject({
            type = "BlockSquare",
            position = rollLocation,
            scale = Vector(1, 0.1, 1),
            sound = false,
            callback_function = function(chit)
               chit.setLock(true)
               chit.setColorTint(Color.Black)
               chit.setName(name)
               chit.setDescription(chitConf.description or "")
               setChitUI(chit)
            end
      })
      table.insert(chits, spawnedChit)
   end
   return chits
end

function setChitUI(chit)
   chit.UI.setXmlTable({{
            tag = "Text",
            attributes = {
               position = "0 0 -52",
               width = "90",
               height = "90",
               text = chit.getName(),
               color="#dcdccc",
               resizeTextForBestFit=true
            }
   }})
end

-- util functions

-- iterate an "array" table using a function to deterime the sort order
function spairs(t, order)
   -- collect the keys
   local keys = {}
   for k in pairs(t) do keys[#keys+1] = k end

   -- if order function given, sort by it by passing the table and keys a, b,
   -- otherwise just sort the keys 
   if order then
      table.sort(keys, function(a,b) return order(t, a, b) end)
   else
      table.sort(keys)
   end

   -- return the iterator function
   local i = 0
   return function()
      i = i + 1
      if keys[i] then
         return keys[i], t[keys[i]]
      end
   end
end

local radialOffset = 2.2
local heightOffset = 2.2


function findGlobalPosWithLocalDirection(angle)
   local object, distance = self, radialOffset * self.getScale().x
   local oPos, oRot = object.getPosition(), object.getRotation()
   local posX = oPos.x + math.sin( math.rad(angle+oRot.y) ) * distance
   local posY = oPos.y + heightOffset
   local posZ = oPos.z + math.cos( math.rad(angle+oRot.y) ) * distance
   return {x=posX, y=posY, z=posZ}
end

local function reversedipairsiter(t, i)
   i = i - 1
   if i ~= 0 then
      return i, t[i]
   end
end
function reversedipairs(t)
   return reversedipairsiter, t, #t + 1
end

function sCopy(orig)
   local orig_type = type(orig)
   local copy
   if(orig_type == 'table') then
      copy = {}
      for orig_key, orig_value in pairs(orig) do
         copy[orig_key] = orig_value
      end
   else -- number, string, boolean, etc
      copy = orig
   end
   return copy
end

function find_objects_by_name(name)
   local objects = {}
   for _, obj in ipairs(getAllObjects()) do
      if obj.getName() == name then
         table.insert(objects, obj)
      end
   end
   return objects
end